(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{400:function(t,_,v){"use strict";v.r(_);var e=v(28),s=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"just-for-interview"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#just-for-interview"}},[t._v("#")]),t._v(" Just For interView")]),t._v(" "),v("h3",{attrs:{id:"_1-什么是闭包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是闭包"}},[t._v("#")]),t._v(" 1. 什么是闭包")]),t._v(" "),v("p",[t._v("引用外部函数数据的内部函数，优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念")]),t._v(" "),v("p",[t._v("闭包有三个特性：")]),t._v(" "),v("p",[t._v("函数嵌套函数、函数内部可以引用外部的参数和变量、参数和变量不会被垃圾回收机制回收")]),t._v(" "),v("h3",{attrs:{id:"_2-什么是原型链"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-什么是原型链"}},[t._v("#")]),t._v(" 2. 什么是原型链")]),t._v(" "),v("h3",{attrs:{id:"_3-es6新语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-es6新语法"}},[t._v("#")]),t._v(" 3. ES6新语法")]),t._v(" "),v("p",[t._v("let/const/var")]),t._v(" "),v("p",[t._v("箭头函数，解构赋值，展开运算符")]),t._v(" "),v("p",[t._v("set/map")]),t._v(" "),v("p",[t._v("import/export")]),t._v(" "),v("p",[t._v("for of / forEach / map")]),t._v(" "),v("h3",{attrs:{id:"_4-数组有哪些方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-数组有哪些方法"}},[t._v("#")]),t._v(" 4. 数组有哪些方法")]),t._v(" "),v("p",[t._v("Push添加至尾部 pop移除最后一个 reverse颠倒 shift移除第一个 slice剪切返回部分")]),t._v(" "),v("p",[t._v("Sort排序 splice删除或插入 unshift头部插入tostring转字符串 join转字符串 index of 查找")]),t._v(" "),v("p",[t._v("Filter 过滤满足条件的  concat拼接 map计算新数组  for each每一个元素调用指定函数")]),t._v(" "),v("h3",{attrs:{id:"_5-get和post的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-get和post的区别"}},[t._v("#")]),t._v(" 5. Get和post的区别")]),t._v(" "),v("p",[t._v("get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&进行参数分割。psot将参数存放在HTTP的包体内")]),t._v(" "),v("p",[t._v(".get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制")]),t._v(" "),v("p",[t._v(".get后退不会有影响，post后退会重新进行提交")]),t._v(" "),v("p",[t._v(".get请求可以被缓存，post不可以被缓存")]),t._v(" "),v("p",[t._v(".get请求只URL编码，post支持多种编码方式")]),t._v(" "),v("p",[t._v(".get请求的记录会留在历史记录中，post请求不会留在历史记录")]),t._v(" "),v("p",[t._v(".get只支持ASCII字符，post没有字符类型限制")]),t._v(" "),v("h3",{attrs:{id:"_6-es6的继承和es5的继承有什么不同"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-es6的继承和es5的继承有什么不同"}},[t._v("#")]),t._v(" 6. ES6的继承和ES5的继承有什么不同")]),t._v(" "),v("p",[t._v("ES5的继承时通过 prototype 或构造函数机制来实现。")]),t._v(" "),v("p",[t._v("ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.apply(this)）。")]),t._v(" "),v("p",[t._v("ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改this。")]),t._v(" "),v("p",[t._v("具体的：ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。")]),t._v(" "),v("p",[t._v("注：super 关键字指代父类的实例，即父类的 this 对象。在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。")]),t._v(" "),v("h3",{attrs:{id:"_7-深拷贝-浅拷贝"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-深拷贝-浅拷贝"}},[t._v("#")]),t._v(" 7. 深拷贝，浅拷贝")]),t._v(" "),v("h3",{attrs:{id:"_8-event-loop-事件循环机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-event-loop-事件循环机制"}},[t._v("#")]),t._v(" 8. Event Loop（事件循环机制)")]),t._v(" "),v("p",[t._v("Js是单线程为了模仿多线程进行并发执行，js引擎划分除了两种内存空间，一种是可执行栈，用来存放同步任务（注意是栈，先进后出）；另一种是任务队列，用来存放异步任务（注意时队列，先进先出）")]),t._v(" "),v("h3",{attrs:{id:"_9-什么是bfc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-什么是bfc"}},[t._v("#")]),t._v(" 9. 什么是BFC")]),t._v(" "),v("p",[t._v("IFC     行内格式化上下文")]),t._v(" "),v("p",[t._v("BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。")]),t._v(" "),v("h3",{attrs:{id:"_10-浏览器渲染html页面的一般过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-浏览器渲染html页面的一般过程"}},[t._v("#")]),t._v(" 10. 浏览器渲染html页面的一般过程")]),t._v(" "),v("p",[t._v("1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。")]),t._v(" "),v("p",[t._v("2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 < 用户设置 < 外链样式 < 内联样式 < html中的style。")]),t._v(" "),v("p",[t._v("3.DOM Tree + CSSOM --\x3e 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。")]),t._v(" "),v("p",[t._v("DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。")]),t._v(" "),v("p",[t._v("4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。")]),t._v(" "),v("p",[t._v("以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。")]),t._v(" "),v("h3",{attrs:{id:"_11-清除浮动的多种方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-清除浮动的多种方式"}},[t._v("#")]),t._v(" 11. 清除浮动的多种方式")]),t._v(" "),v("p",[t._v("::after / "),v("br"),t._v(" / clear: both")]),t._v(" "),v("p",[t._v("创建父级 BFC(overflow:hidden)")]),t._v(" "),v("p",[t._v("父级设置高度")]),t._v(" "),v("p",[t._v("触发条件:根元素position: absolute/fixed display: inline-block / table")]),t._v(" "),v("p",[t._v("float 元素ovevflow !== visible")]),t._v(" "),v("p",[t._v("规则:")]),t._v(" "),v("p",[t._v("属于同一个 BFC 的两个相邻 Box 垂直排列属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠BFC 的区域不会与 float 的元素区域重叠计算 BFC 的高度时，浮动子元素也参与计算文字层不会被浮动层覆盖，环绕于周围")]),t._v(" "),v("h3",{attrs:{id:"_12-继承的几种方式及优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-继承的几种方式及优缺点"}},[t._v("#")]),t._v(" 12. 继承的几种方式及优缺点")]),t._v(" "),v("p",[t._v("借用构造函数继承，使用call或apply方法，将父对象的构造函数绑定在子对象上")]),t._v(" "),v("p",[t._v("原型继承，将子对象的prototype指向父对象的一个实例")]),t._v(" "),v("p",[t._v("组合继承")]),t._v(" "),v("p",[t._v("原型链继承的缺点")]),t._v(" "),v("p",[t._v("字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。")]),t._v(" "),v("p",[t._v("借用构造函数（类式继承）")]),t._v(" "),v("p",[t._v("借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。")]),t._v(" "),v("p",[t._v("组合式继承")]),t._v(" "),v("p",[t._v("组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性")]),t._v(" "),v("h3",{attrs:{id:"_13-gc垃圾回收机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-gc垃圾回收机制"}},[t._v("#")]),t._v(" 13. GC垃圾回收机制")]),t._v(" "),v("h3",{attrs:{id:"_14-回流重绘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-回流重绘"}},[t._v("#")]),t._v(" 14. 回流重绘")]),t._v(" "),v("p",[t._v("回流（重排 reflow）：对DOM树进行渲染，只要修改DOM或修改元素的形状大小，就会触发reflow，reflow的时候，浏览器会使已渲染好受到影响的部分失效，并重新构造这部分，完成reflow后，浏览器会重新绘制受影响的部分到屏幕中.")]),t._v(" "),v("p",[t._v("重绘(repaint)：当我们对DOM的修改导致的样式变化，但未影响几何属性时，浏览器不需要重新计算元素的几何属性，直接可以为该元素绘制新的样式，跳过了回流环节，这个过程就叫重绘.")]),t._v(" "),v("p",[t._v("****回流必定会发生重绘，重绘不一定发生回流********,****能用重绘就不要用回流了")]),t._v(" "),v("h3",{attrs:{id:"_15-跨域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-跨域"}},[t._v("#")]),t._v(" 15. 跨域")]),t._v(" "),v("p",[t._v("域名端口号协议有一个不一样即为跨域，")]),t._v(" "),v("p",[t._v("解决方法有：Jsonp ,webpack/ nginx反向代理, websocket ,cors")]),t._v(" "),v("h3",{attrs:{id:"_16-什么是mvvm什么是mvc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-什么是mvvm什么是mvc"}},[t._v("#")]),t._v(" 16. 什么是mvvm什么是mvc")]),t._v(" "),v("p",[t._v("MVC是模型-视图-控制器，MVC是单向通信，数据和视图通过controller承上启下")]),t._v(" "),v("p",[t._v("MVVM是Model-View-ViewModel模型-视图-视图模型。m是后端传递的数据，v是所看到的页面，vm视图模型有两个方向，一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面，实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。")]),t._v(" "),v("p",[t._v("总结：在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel作为observer观察者，当数据发生变化，能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。")]),t._v(" "),v("p",[v("a",{attrs:{href:"javascript:void(function(){document.scrollingElement.scrollIntoView({behavior:'smooth'})})()"}},[t._v("回到顶部")])])])}),[],!1,null,null,null);_.default=s.exports}}]);