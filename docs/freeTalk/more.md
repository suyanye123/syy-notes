## 高频面试题

https://juejin.cn/post/7073869980411887652

JS数据类型

number，string，boolean，null，undefined ，ES6 中添加了一种原始数据类型 symbol，ES7新增bigInt。

object，array，function  引用数据类型

什么是BFC：

```
IFC     行内格式化上下文

BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。
```

什么是盒模型



### 一、ES6新特性

- 迭代器 ，新增for of	 for...of 循环可以遍历数组、Set 和 Map 结构、某些类似数组的对象、对象，以及字符串
- set map数据结构   Set 数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数
- promise   async await(ES7)
- let const
- 箭头函数、解构赋值、三点展开运算符、模板字符串
- import、export（Commonjs -- require 引入 module.expose暴露）
- class
- proxy、reflect

### 二、在new的过程发生了什么

提示：4件事  

- 创建一个新对象，
- 将新对象指定为构造函数的this，
- 执行函数中的代码，
- 返回新对象



### 三、 ES5和ES6的继承 todo

- ES5的继承是通过构造函数和prototype来实现的，先创建子类的实例对象，然后将父类的方法指向新的this

- ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改this。

  具体的：ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。

  ps：super 关键字指代父类的实例，即父类的 this 对象。在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。

借用构造函数继承，使用call或apply方法，将父对象的构造函数绑定在子对象上

原型继承，将子对象的prototype指向父对象的一个实例

组合继承

原型链继承的缺点

字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。

借用构造函数（类式继承）

借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。

组合式继承

组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性

### 四、数组有哪些方法

push-返回新长度； pop-删除并返回最后一个 ； concat-数组拼接，返回新数组；

join(',') - 数组转成字符串拼接，默认符号为，返回新字符串，传' '时为无拼接符号；

 reverse-反转数组，更改原数组并返回； 	 shift-删除返回第一个元素；

 slice(start,end)-截取数组一部分，包含开始，不包含结束，返回新数组； 	 sort：排序，改变原数组；

 tostring-转字符串； unshift-开头添加，返回新长度；

forEach (item,index,items)遍历;



### 五、对象有哪些方法

map foreach

### 六、拷贝，浅拷贝有哪些方法

浅拷贝： …展开 ，

### 什么是浅拷贝？什么是深拷贝？E:\syy-template\src\pages\other\index.vue

浅拷贝：浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。

深拷贝：深拷贝会将源对象从内存中完整的拷贝一份出来放在堆内存中，**修改源对象不会对新对象产生任何影响。**

### 如何实现浅拷贝

#### Object.assign

```
const source = {
	a: 1,
  b: 'i am b',
  c: {
    d: 'i am d',
    e: 2,
  }
}
const target = Object.assign({}, source);

source.a = 11; // 修改源对象的基本类型值，
console.log(target.a); // 1   TODO: 目标对象的基础类型值不会改变

source.c.d = 'i am copy d'; // 修改源对象的引用类型，
console.log(target.c.d); // i am copy d   TODO: 目标对象的引用类型值会改变
```

####  扩展运算符

```
const source = {
	a: 1,
  b: 'i am b',
  c: {
    d: 'i am d',
    e: 2,
  }
}
const target = {...source}

source.a = 11; // 修改源对象的基本类型值，
console.log(target.a); // 1   TODO: 目标对象的基础类型值不会改变

source.c.d = 'i am copy d'; // 修改源对象的引用类型，
console.log(target.c.d); // i am copy d   TODO: 目标对象的引用类型值会改变
```

#### 数组API

```js
//Array.prototype.slice
const source = [{a: 1}, {b: 2}, {c: 3}];

const target = source.slice(0,2); //  [{a: 1}, {b: 2}]

source[0].a = 11;
console.log(target[0].a); // 11   修改源对象的引用类型,目标对象的引用类型值会改变

// Array.prototype.concat
const source = [{a: 1}, {b: 2}, {c: 3}];

const target = source.concat([{d: 4}]); //   [{a: 1}, {b: 2}, {c: 3}, {d: 4}];

source[0].a = 11;
console.log(target[0].a); // 11   修改源对象的引用类型,目标对象的引用类型值会改变
```

### 如何实现深拷贝？

#### JSON.parse(JSON.stringify(...))

```js
const source = {
	a: 1,
  b: 'i am b',
  c: {
    d: 'i am d',
    e: 2,
  },
  f: () => console.log('i am f'), // function
  g: undefined,	// undefined
  h: Symbol('i am h'), // Symbol
  k: new Date(0),
  l: /23232/,
  m: NaN,
  n: Infinity,
}
// 对象循环引用
// source.o = source

// 给对象添加不可枚举类型
Object.defineProperty(source, 'j', {
	value: 'i am j',
  enumerable: false,
})

// 给对象添加Symbol类型的属性
const p = Symbol.for('p')
source[p] = 'i am p';

const target = JSON.parse(JSON.stringify(source))

source.a = 11; // 修改源对象的基本类型值，
console.log(target.a); // 1   TODO: 目标对象的基础类型值不会改变

source.c.d = 'i am copy d'; // 修改源对象的引用类型，
console.log(target.c.d); // i am d  目标对象的引用类型值【不会】改变
//当源对象中存在undefined、function等类型的值时，在copy过程会丢失该属性,源对象的属性是Symbol类型时，在copy过程会丢失该属性,无法拷贝对象的不可枚举类型,无法拷贝对象的原型链,无法拷贝Date引用类型，会变成字符串,拷贝RegExp类型的引用时会变成空对象,当源对象中有值为NaN、Infinity 类型时会出现序列化为null,当源对象中出现对象的循环引用问题，会直接报错. 在我们使用JSON API来实现深拷贝的时候会有很多限制，但是在项目中实现简单的对象copy还是最方便的方式之一。
```

#### MessageChannel实现

```js
//这个方法可以实现对象中不包含函数和symbol类型的拷贝
function cloneByMessageChannel(sourceObj) {
	return new Promise((resolve) => {
  	const { port1, port2 } = new MessageChannel()
    port1.onmessage = (ev) => {
      resolve(ev.data)
    }
    port2.postMessage(sourceObj)
  })
}
(async () => {
	const targetObj = await cloneByMessageChannel(sourceObj)
  console.log('targetObj', targetObj)
})()
```

#### 自己实现一个深拷贝

```
function cloneDeeps(source) {
	const target = {};
  for(let key in source) {
  	if (typeof source[key] === 'object') {
     target[key] = cloneDeeps(source[key]);
    } else {
    	target[key] = source[key]
    }
  }
  return target;
}
//上面按钮可以实现简单的深拷贝功能了，但是还有几个值得优化的地方
1、当传入的对象是null，目前方法会返回{}
2、当值为RegExp和Date类型的时候会返回{}
3、没有兼容数组
4、不可枚举类型不能拷贝
```



### 七、Event Loop   todo

事件循环机制：Js是单线程为了模仿多线程进行并发执行，js引擎划分除了两种内存空间，一种是可执行栈，用来存放同步任务（注意是栈，先进后出）；另一种是任务队列，用来存放异步任务（注意时队列，先进先出）

每一个任务有一个或多个回调函数（callback），当前一个任务结束后，此时不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就会执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。这种模式所执行的任务被称为异步任务。
异步任务指的是，不进入主线程、而进入"任务队列”（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。所有同步任务都在主线程（由JS引擎维护，用来负责解释和执行JavaScript代码）上执行，形成一个执行栈（execution context stack）。
2、主线程之外，还存在一个"消息队列"（queue）（特点：先进先出）。只要异步任务有了运行结果，就在"消息队列"之中放置一个事件。
3、一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"消息队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
4、主线程不断重复上面的第三步。

宏任务： dom事件回调 ajax回调 定时器回调 

微任务：promise回调 mutation回调

微任务的执行时机，晚于当前本轮事件循环的 Call Stack（调用栈）中的代码（宏任务），早于事件处理函数和定时器函数。减少操作中用户可感知到的延迟。确保任务顺序的一致性，即便当结果或数据是同步可用的。批量操作的优化



### 八、http协议流程

三次握手四次挥手



### 九、get、post区别

get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&进行参数分割。psot将参数存放在HTTP的包体内

.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制

.get后退不会有影响，post后退会重新进行提交

.get请求可以被缓存，post不可以被缓存

.get请求只URL编码，post支持多种编码方式

.get请求的记录会留在历史记录中，post请求不会留在历史记录

.get只支持ASCII字符，post没有字符类型限制

什么是ajax，axios

①　创建对象 const xhr = new XMLhttpRequest()

②　初始化  xhr.open(‘GET’, ‘URL ’ )      可以设置 setRequestHeader

③　发送   xhr.send()

④　事件绑定 xhr.onreadystatechange =function(){ if (xhr.readystate===4){

If(xhr.status==200) }     else{}    }

### 十、原型链、instance of、闭包

引用外部函数数据的内部函数，优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念

闭包有三个特性：

函数嵌套函数、函数内部可以引用外部的参数和变量、参数和变量不会被垃圾回收机制回收

### 十一、Promise

### 十二、JS事件

事件绑定，事件冒泡，事件捕获

```js
//手写事件代理
```

### 十三、跨域

### 十四、手写练习

- 防抖、节流

```js
throttle(){

}

debounce(){

}
```



## Vue篇

### 一、回流、重绘

浏览器渲染整个过程：

1.浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。

2.浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 < 用户设置 < 外链样式 < 内联样式 < html中的style。

3.DOM Tree + CSSOM --> 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。

DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。

4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。

以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。

回流（重排 reflow）：对DOM树进行渲染，只要修改DOM或修改元素的形状大小，就会触发reflow，reflow的时候，浏览器会使已渲染好受到影响的部分失效，并重新构造这部分，完成reflow后，浏览器会重新绘制受影响的部分到屏幕中.

重绘(repaint)：当我们对DOM的修改导致的样式变化，但未影响几何属性时，浏览器不需要重新计算元素的几何属性，直接可以为该元素绘制新的样式，跳过了回流环节，这个过程就叫重绘.

***\*回流必定会发生重绘，重绘不一定发生回流\*******\*,\****能用重绘就不要用回流了



### 二、组件通信

vuex， props，$emit，provide/inject，eventbus事件总线，订阅发布，本地缓存，

Cookie,sessionstorage,localstorage的区别

Cookie大小限制为4KB左右。它的主要用途有保存登录信息，

Loaclstorage一直存在，存在于本地。。。。用来存放token，通过在请求头加jwt进行跨域验证

Sessionstorage会话期间存在，存在服务器

### 三、computed、watch

- computed-计算属性，是通过已有属性计算新值，然后挂载到vm实例上

底层还是借助object.defineProperty的get、set实现的

结算属性得到的值可以缓存，不会每次使用时都调用getter，
只有第一次初始化时，或者依赖的数据发生变化时才调用getter

并且vue中调用computed的是vm实例，取data里的数据要使用this，在computed中注意不要使用箭头函数

- watch



### 四、v-for中为什么要绑定key

虚拟dom，diff算法



### 六、数据双向绑定

### 七、webpack

### 十、vue2与vue3的差异

#### 1. 生命周期的改变

vue2: 

```

```
vue3:
```
 beforeCreated created beforeMounted mounted 
```

#### 2. template中支持多个子节点

用`fragment`作为根节点包裹，最终不会渲染fragent

#### 3. 响应性的改变

```js
// vue2响应式数据基于 object.defineProperty ，在初始化的时候需要递归遍历属性，然后通过数据劫持实现响应式。
// vue2不能检测到对象属性的添加、删除；可以使用 $set来添加对象属性
// 不能检测到数组内部元素根据index进行修改、length修改；但是可以使用vue2封装好的7个数组方法进行操作，或使用$set
```

```js
// vue3响应式基于 Proxy代理实现的，性能有很大提升，且响应式不区分数组和对象，可以检测到其内部的更改
//同时暴露了一些api,比如 ref、reactive 等等，用于声明响应式数据
```

#### 4. compositonAPI

vue3新增 setup函数，接受props和context两个参数，setup在beforeCreated与created之间执行，此时数据还未解析初始化，所以setup里的this被设定为undfined

在 `setup `中将同一业务逻辑代码写在一起，将返回的所有内容都暴露给组件的其余部分 ，即为组合API，可以很方便的进行抽离和复用，取代Vue2中的mixin

#### 5.`<script setup>`     todo

setup语法糖

- 组件自动注册：在 script setup 中，引入的组件可以直接使用，无需再通过`components`进行注册，并且无法指定当前组件的名字，它会自动以文件名为主，也就是不用再写`name`属性了。示例：

```vue
<template>
    <Child />
</template>
<script setup>
import Child from './Child.vue'
</script>
```

如果需要定义类似 name 的属性，可以再加个平级的 script 标签，在里面实现即可。

https://juejin.cn/post/6983626263327932429?utm_source=gold_browser_extension

https://www.jianshu.com/p/f97c029b1725

## CSS篇

### 一、flex布局

**就比如面试官问让我讲一下flex**

我的回答：flex弹性盒是CSS3中引入的新型布局方案，这里分两个概念，一个为弹性容器，就是开启了display：flex的元素，还有一个概念为弹性元素，是弹性容器的直接子元素。

弹性元素中分主轴和副轴，我们可以使用flex-dire ction来改变主轴的方向，默认为水平，自左向右。而副轴就是主轴的垂直方向，默认为垂直方向。

有一个flex-wrap控制弹性元素是否可以换行，默认为不换行nowrap。弹性元元素中有一个justify-content可以改变主轴上弹性元素的对齐方式或者空白空间的分布，我们常用justify-content：center来实现弹性元素的水平居中。

弹性容器中还有一个align-items来控制弹性元素在副轴上的位置，我们常用align-items：center来实现弹性元素的垂直居中。

接下来到弹性元素的属性，有一个 flex-grow来控元素生长系数，通过flex-shrink来控制收缩系数，还有一个flex-basis控制元素的大小，如果主轴为水平方向，则basis相当于width，如果主轴方向为垂直，basis相当于height。

我们可以使用flex:对以上三个属性进行简写，一般为flex:1 1 auto，然后可以通过order来控制弹性元素的显示顺序。

```html
<div class='box'>
	<span class='item'/>
</div>
```

```html
<div class="box">
  <div class="column">
    <span class="item"></span>
    <span class="item"></span>
  </div>
  <div class="column">
    <span class="item"></span>
    <span class="item"></span>
  </div>
</div>
```

<img src="..\.vuepress\alias\bqb\o35hYFvQkimzH8b.png" alt="1" style="zoom: 33%;" />

```css
.box{display:flex}	//1
.box{display:flex;justyfy-content:center} //2
```



### 二、grid布局





### 三、一些奇怪的练习

-  多种方法实现水平居中

```
flex 、 margin：auto 、text-align:center、position：absolute
```

- 清除浮动的几种方式，及原理

```
::after / <br> / clear: both
创建父级 BFC(overflow:hidden)
父级设置高度
触发条件:根元素position: absolute/fixed display: inline-block / table
float 元素ovevflow !== visible
规则:
属于同一个 BFC 的两个相邻 Box 垂直排列属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠BFC 的区域不会与 float 的元素区域重叠计算 BFC 的高度时，浮动子元素也参与计算文字层不会被浮动层覆盖，环绕于周围
```

- 用css画一个三角形
- 

### 四、定义





## HTTP篇

大概了解 有几种HTTP请求方式？每种方式的显著特点？ 



缓存策略 http2做了哪些优化 ？可能会出现的性能问题点 ？



https的工作原理？ssl在哪些层生效？

### 1、谈下你对五层网络协议体系结构的理解？

学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。

- **1. 应用层**

应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。

- **2. 运输层**

运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。

由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。

- **3. 网络层**

在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。

- **4. 数据链路层**

数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。

在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。

- **5. 物理层**

在物理层上所传送的数据单位是比特。物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

### 2、简单说下每一层对应的网络协议有哪些？

计算机五层网络体系中涉及的协议非常多，下面就常用的做了列举：

![计算机网络太难？了解这一篇就够了](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/24/16d61cdfcf43eedd~tplv-t2oaga2asx-watermark.awebp)

### 3、ARP 协议的工作原理？

网络层的 ARP 协议完成了 IP 地址与物理地址的映射。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。

此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。

### 4、谈下你对 IP 地址分类的理解？

IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址编址方案将 IP 地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。

每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：

A 类地址：以 0 开头，第一个字节范围：0~127；

B 类地址：以 10 开头，第一个字节范围：128~191；

C 类地址：以 110 开头，第一个字节范围：192~223；

D 类地址：以 1110 开头，第一个字节范围为 224~239；

E 类地址：以 1111 开头，保留地址

### 5、TCP 的主要特点是什么？

\1. TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；

\2. 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；

\3. TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；

\4. TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；

\5. 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

### 6、UDP 的主要特点是什么？

\1. UDP 是无连接的；

\2. UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；

\3. UDP 是面向报文的；

\4. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；

\5. UDP 支持一对一、一对多、多对一和多对多的交互通信；

\6. UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。

### 7、TCP 和 UDP 的区别？

TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等。

### 8、TCP 和 UDP 分别对应的常见应用层协议有哪些？

- **1. TCP 对应的应用层协议**

FTP：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。

Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是-纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。

SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。

POP3：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Fo-xmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163 邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。

HTTP：从 Web 服务器传输超文本到本地浏览器的传送协议。

- **2. UDP 对应的应用层协议**

DNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。

SNMP：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。

TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。

### 9、详细说下 TCP 三次握手的过程？

- **1. 三次握手**

TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。

![计算机网络太难？了解这一篇就够了](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/24/16d61cbcef672eb5~tplv-t2oaga2asx-watermark.awebp)

最初客户端和服务端都处于 CLOSED(关闭) 状态。本例中 A（Client） 主动打开连接，B（Server） 被动打开连接。

一开始，B 的 TCP 服务器进程首先创建传输控制块TCB，准备接受客户端进程的连接请求。然后服务端进程就处于 LISTEN(监听) 状态，等待客户端的连接请求。如有，立即作出响应。

第一次握手：A 的 TCP 客户端进程也是首先创建传输控制块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。

第二次握手：B 收到连接请求报文后，如果同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。

第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。

### 10、为什么两次握手不可以呢？

为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就误认为 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。

对于上面这种情况，如果不进行第三次握手，B 发出确认后就认为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。

如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。

### 11、为什么不需要四次握手？

有人可能会说 A 发出第三次握手的信息后在没有接收到 B 的请求就已经进入了连接状态，那如果 A 的这个确认包丢失或者滞留了怎么办？

我们需要明白一点，完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。

### 12、Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN？

接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。

SYN 是 TCP / IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符，在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误]）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

### 13、传了 SYN，为什么还要传 ACK？

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。

### 14、详细说下 TCP 四次挥手的过程？

据传输结束后，通信的双方都可以释放连接。现在 A 和 B 都处于 ESTABLISHED 状态。



![计算机网络太难？了解这一篇就够了](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/24/16d61cb0506aea3f~tplv-t2oaga2asx-watermark.awebp)

第一次挥手：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。

第二次挥手：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B 前面已经传送过的数据的最后一个字节的序号加1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2)状态，等待 B 发出的连接释放报文段。

第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认)状态，等待 A 的确认。

第四次挥手：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号 seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果 B 一收到 A 的确认就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。

### 15、为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？

\1. 为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。

\2. 防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。

### 16、为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么?

当服务器执行第二次挥手之后, 此时证明客户端不会再向服务端请求任何数据, 但是服务端可能还正在给客户端发送数据（可能是客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完的数据传输完毕之后再发送关闭请求。

### 17、保活计时器的作用？

除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。

服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。

### 18、TCP 协议是如何保证可靠传输的？

\1. 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；

\2. 对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；

\3. 丢弃重复数据：对于重复数据，能够丢弃重复数据；

\4. 应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

\5. 超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

\6. 流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。

### 19、谈谈你对停止等待协议的理解？

停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到、确认丢失和确认迟到。

### 20、谈谈你对 ARQ 协议的理解？

- **自动重传请求 ARQ 协议**

停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。

- **连续 ARQ 协议**

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

### 21、谈谈你对滑动窗口的了解？

TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。

TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。

### 22、谈下你对流量控制的理解？

TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### 23、谈下你对 TCP 拥塞控制的理解？使用了哪些算法？

拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。

拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP 的拥塞控制采用了四种算法，即：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM），以减少网络拥塞的发生。

- **慢开始：**

慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。

- **拥塞避免：**

拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。

- **快重传与快恢复：**

在 TCP/IP 中，快速重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。

没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。

有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和快恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

### 24、什么是粘包？

在进行 Java NIO 学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。

\1. TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；

\2. 从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。

基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。

接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。

### 25、TCP 黏包是怎么产生的？

- **发送方产生粘包**

采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。

- **接收方产生粘包**

接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）

### 26、怎么解决拆包和粘包？

分包机制一般有两个通用的解决方法：

\1. 特殊字符控制；

\2. 在包头首都添加数据包的长度。

如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。

tips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。

### 27、你对 HTTP 状态码有了解吗？

- **1XX 信息**

\1. 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

- **2XX 成功**

\1. 200 OK

\2. 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。

\3. 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

- **3XX 重定向**

\1. 301 Moved Permanently ：永久性重定向；

\2. 302 Found ：临时性重定向；

\3. 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。

\4. 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。

\5. 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

- **4XX 客户端错误**

\1. 400 Bad Request ：请求报文中存在语法错误。

\2. 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。

\3. 403 Forbidden ：请求被拒绝。

\4. 404 Not Found

- **5XX 服务器错误**

\1. 500 Internal Server Error ：服务器正在执行请求时发生错误；

\2. 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

### 28、HTTP 状态码 301 和 302 代表的是什么？有什么区别？

301，302 都是 HTTP 状态的编码，都代表着某个 URL 发生了转移。

- **区别：**

301 redirect: 301 代表永久性转移（Permanently Moved）

302 redirect: 302 代表暂时性转移（Temporarily Moved）

### 29、forward 和 redirect 的区别？

Forward 和 Redirect 代表了两种请求转发方式：直接转发和间接转发。

直接转发方式（Forward）：客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。

间接转发方式（Redirect）：实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。

- 举个通俗的例子：　

直接转发就相当于：“A 找 B 借钱，B 说没有，B 去找 C 借，借到借不到都会把消息传递给 A”；

间接转发就相当于："A 找 B 借钱，B 说没有，让 A 去找 C 借"。

### 30、HTTP 方法有哪些？

客户端发送的 请求报文 第一行为请求行，包含了方法字段。

\1. GET：获取资源，当前网络中绝大部分使用的都是 GET；

\2. HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；

\3. POST：传输实体主体

\4. PUT：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。

\5. PATCH：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。

\6. OPTIONS：查询指定的 URL 支持的方法；

\7. CONNECT：要求在与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

\8. TRACE：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。

### 31、说下 GET 和 POST 的区别？

GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。

本质区别：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。

\1. 从功能上讲，GET 一般用来从服务器上获取资源，POST 一般用来更新服务器上的资源；

\2. 从 REST 服务角度上说，GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；

\3. 从请求参数形式上看，GET 请求的数据会附在 URL 之后，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 & 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的 请求体 中；

\4. 就安全性而言，POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；

\5. 从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。

### 32、在浏览器中输入 URL 地址到显示主页的过程？

\1. DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；

\2. TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；

\3. 发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；

\4. 服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；

\5. 浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

\6. 连接结束。

### 33、DNS 的解析过程？

\1. 主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。

\2. 本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。

### 34、谈谈你对域名缓存的了解？

为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。

由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。

不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。

### 35、谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？

在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。

而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码

```java
Connection:keep-aliveCOPY
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。

Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

### 36、谈下 HTTP 1.0 和 1.1、1.2 的主要变化？

- **HTTP1.1 的主要变化：**

\1. HTTP1.0 经过多年发展，在 1.1 提出了改进。首先是提出了长连接，HTTP 可以在一次 TCP 连接中不断发送请求。

\2. 然后 HTTP1.1 支持只发送 header 而不发送 body。原因是先用 header 判断能否成功，再发数据，节约带宽，事实上，post 请求默认就是这样做的。

\3. HTTP1.1 的 host 字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到 host。

- **HTTP2.0 的主要变化：**

\1. HTTP2.0 支持多路复用，同一个连接可以并发处理多个请求，方法是把 HTTP数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个 HTTP请求顺序到达；

\2. HTTP2.0 支持服务端推送，就是服务端在 HTTP 请求到达后，除了返回数据之外，还推送了额外的内容给客户端；

\3. HTTP2.0 压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少；

\4. HTTP2.0 适用于 HTTPS 场景，因为其在 HTTP和 TCP 中间加了一层 SSL 层。

### 37、HTTPS 的工作过程？

\1. 客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；

\2. 服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构；

\3. 客户端收到网站的证书之后要做下面的事情：

- 3.1 验证证书的合法性；
- 3.2 果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密；
- 3.3 用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。

\4. 服务器接收到客户端传送来的信息，要做下面的事情：

- 4.1 用私钥解析出密码，用密码解析握手消息，验证 hash 值是否和浏览器发来的一致；
- 4.2 使用密钥加密消息；

\5. 如果计算法 hash 值一致，握手成功。

### 38、HTTP 和 HTTPS 的区别？

\1. 开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；

\2. 资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；

\3. 端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；

\4. 安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

### 39、HTTPS 的优缺点？

- **优点：**

\1. 使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

\2. HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；

\3. HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

- **缺点：**

\1. HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；

\2. HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；

\3. SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；

\4. SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；

\5. HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。

### 40、什么是数字签名？

为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。

### 41、什么是数字证书？

对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。

### 42、什么是对称加密和非对称加密？

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。

非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

### 43.进程和线程的通信方式

> 线程：进程变量，临界区，事件，消息，信号量，端口通信，管道，共享内存
>
> 进程：信号，消息，信号量，端口通信，管道，共享内存

#### 一、进程间的通信方式

管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

信号量(semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

信号 (sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

共享内存(shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

套接字(socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

#### 二、线程间的通信方式

锁机制：包括互斥锁、条件变量、读写锁

   *互斥锁提供了以排他方式防止数据结构被并发修改的方法。
   *读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
   *条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量

信号机制(Signal)：类似进程间的信号处理

***线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。***




## 乱序

1、前端常用布局方式有哪些?请用2种方式实现圣杯布局
2、防抖和节流的区别
3、闭包是什么，有什么特性，对页面有什么影响?
4、请手写一个promise
5、给定两个数组，写一个方法来计算它们的交集。例: nums1 = [1,2,2,1]，nums2 =(2,2]，返回2,2]6、代码实现找出数组中第k大的数出现次数，例数组【1，2，4，4，3，5】第二大的数字4，出现几次
7、使用js 实现一个冒泡排序
8、 console.log(0.1 +0.2)执行结果是什么?为什么
9、如何实现sleep 的效果
10、给两个构造函数A和B，如何实现A继承B?
11、vue 如何实现按需加载配合webpack 设置?
12、computed 和 watch 的区别和运用的场景?
13、怎样理解vue 的单向数据流?
14、你有对 Vue项目进行哪些优化?
15、vue 如何优化首屏加载速度?
16、直接给一个数组项赋值，Vue能检测到变化吗?
17、请写出 vue的生命周期
18、Vue 组件间通信有哪几种方式?
19、请写出vue中混入的作用?
20、 vue中怎样实现动态组件?
21、如何用css实现一个三角形?
22、Label的作用是什么?怎么用？
23、-下你对HTML语义化的理解?
24、什么是渐进式渲染(progressive rehderihg)
25、JavaScript原型,原型链?有什么特点?
26、WEB应用从服务器主动推送 Data 到客户端有那些方式?
27、说说你对AMD和 CommonJS的了解。
28、React  refs 的作用是件么?
29、介绍下虚拟 dom
30、介绍下不可变数据Immutability



1、https加密原理，证书校验原理；

2、前端跨域问题的原因及解决方式，跨域时的状态码；

3、前端安全问题及应对策略；

4、如何提升前端性能，有哪些指标？

5、前端加密方式有哪些？

6、前端如何生成用户唯一id（guid）？

7、typescript解决了什么问题，有什么优缺点？

8、typescript泛型是什么？

9、typescript有哪些工具类型？

10、vue双向绑定原理；

11、computed和watch的区别；

12、vnode diff过程；

13、webpack HMR原理；

14、自己做过最复杂的项目详细介绍（会一直追问）；

15、用性能最高的方法封装函数实现本功能：支持传入一个升序数组，传入一个目标值target，返回target的位置；

16、手写发布订阅模式EventEmitter；

17、写一个函数实现类似Promise.all的功能，但对同时执行的promise个数有限制。函数支持传入一个数组（数组元素为promise），以及一个limit，例如fn([promise1,promise2,promise3,promise4],3),表示同时最多只能执行3个promise，并在所有promise执行完成后返回结果；



1、tcp协议如何解决丢包问题？错误恢复机制是什么样的？

2、讲一下websocket的原理；

3、xss攻击如何防御；

4、亮点项目介绍（会一直追问😢）；

<a href="javascript:void(function(){document.scrollingElement.scrollIntoView({behavior:'smooth'})})()">回到顶部</a>



