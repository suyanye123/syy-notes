(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{429:function(t,e,a){"use strict";a.r(e);var r=a(28),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"深入vue2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深入vue2"}},[t._v("#")]),t._v(" 深入Vue2")]),t._v(" "),a("h3",{attrs:{id:"一、响应式原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、响应式原理"}},[t._v("#")]),t._v(" 一、响应式原理")]),t._v(" "),a("p",[t._v("当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，\n并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。\nObject.defineProperty 是 ES5 中一个无法 shim 的特性，\n这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。")]),t._v(" "),a("p",[t._v("每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。\n之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。")]),t._v(" "),a("p",[t._v("但是由于javascript的限制，vue不能检测数组和对象的变化，\n因为vue无法检测属性的添加或移除，所以property必须在data对象中保存，vue才能转化为响应式")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var vm = new Vue({\n  data:{\n    a:1\n  }\n})\n// `vm.a` 是响应式的\nvm.b = 2\n// `vm.b` 是非响应式的\n")])])]),a("p",[t._v("对于已经创建的实例，vue不允许动态添加根级别的响应式property\n此时可以使用Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property\n或者vm.$set实例方法（全局vue.set方法的别名）")]),t._v(" "),a("h2",{attrs:{id:"es5和es6中set和get方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es5和es6中set和get方法"}},[t._v("#")]),t._v(" ES5和ES6中set和get方法")]),t._v(" "),a("p",[t._v("ES5中\n情况一：对象已经创建，需要给上面添加setget方法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('//如果使用defineProperty定义setget，默认configurable: false，enumerable: false\n        var obj={_a:0};\n        Object.defineProperty(obj,"a",{\n            configurable:false,\n            enumerable:false,\n            set:function (value) {\n                this._a=value;\n            },\n            get:function () {\n                return this._a;\n            }\n        });\n')])])]),a("p",[t._v("情况二：当创建对象时，使用这种写法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('//当使用对象设置setget时，configurable: true，enumerable: true\n        var obj1={\n            _a:0,\n            set a(value){\n                this._a=value;\n            },\n            get a(){\n                return this._a;\n            }\n        };\n        console.log(Object.getOwnPropertyDescriptor(obj1,"a"));\n')])])]),a("p",[t._v("ES6种\nclass Box{")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("        constructor(){\n            this._data=null;\n        }\n        set data(value){\n            this._data=value;\n        }\n        get data(){\n            return this._data;\n        }\n    }\n")])])]),a("h3",{attrs:{id:"二、组件之间传值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、组件之间传值"}},[t._v("#")]),t._v(" 二、组件之间传值")]),t._v(" "),a("h4",{attrs:{id:"_1-父传子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-父传子"}},[t._v("#")]),t._v(" 1.父传子")]),t._v(" "),a("p",[t._v("props")]),t._v(" "),a("h4",{attrs:{id:"_2-子传父"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-子传父"}},[t._v("#")]),t._v(" 2.子传父")]),t._v(" "),a("p",[t._v("$emit")]),t._v(" "),a("h4",{attrs:{id:"_3-兄弟组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-兄弟组件"}},[t._v("#")]),t._v(" 3.兄弟组件")]),t._v(" "),a("h5",{attrs:{id:"通过eventbus"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过eventbus"}},[t._v("#")]),t._v(" 通过eventBus")]),t._v(" "),a("h4",{attrs:{id:"_4-祖先组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-祖先组件"}},[t._v("#")]),t._v(" 4.祖先组件")]),t._v(" "),a("h5",{attrs:{id:"inject-provide"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inject-provide"}},[t._v("#")]),t._v(" inject\\provide")]),t._v(" "),a("h6",{attrs:{id:"缺点-传递给后代的数据不是响应式的-除非祖先组件在注入时以响应式的方式注入数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点-传递给后代的数据不是响应式的-除非祖先组件在注入时以响应式的方式注入数据"}},[t._v("#")]),t._v(" 缺点：传递给后代的数据不是响应式的，除非祖先组件在注入时以响应式的方式注入数据")]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"二、缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、缓存"}},[t._v("#")]),t._v(" 二、缓存")]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"三、vuex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、vuex"}},[t._v("#")]),t._v(" 三、VueX")]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("四、")])])}),[],!1,null,null,null);e.default=s.exports}}]);