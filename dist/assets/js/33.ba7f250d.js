(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{415:function(e,t,n){"use strict";n.r(t);var r=n(28),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"什么是shim-和-polyfill-param"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是shim-和-polyfill-param"}},[e._v("#")]),e._v(" 什么是shim 和 polyfill，@param")]),e._v(" "),n("p",[e._v("Published on Feb 7, 2021 in "),n("a",{attrs:{href:"https://106.54.190.214/index.php/category/web%E5%89%8D%E7%AB%AF/",target:"_blank",rel:"noopener noreferrer"}},[e._v("web前端"),n("OutboundLink")],1),e._v(" with "),n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/110/#comments",target:"_blank",rel:"noopener noreferrer"}},[e._v("0 comment"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("在学习和使用 JavaScript 的时候，我们会经常碰到两个术语：shim 和 polyfill。它们有许多定义和解释，意思相近又有差异。")]),e._v(" "),n("h2",{attrs:{id:"shim"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#shim"}},[e._v("#")]),e._v(" Shim")]),e._v(" "),n("p",[e._v("Shim 指的是在一个旧的环境中模拟出一个新 API ，而且仅靠旧环境中已有的手段实现，以便所有的浏览器具有相同的行为。主要特征：")]),e._v(" "),n("p",[e._v("该 API 存在于现代浏览器中;\n浏览器有各自的 API 或 可通过别的 API 实现;\nAPI 的所有方法都被重新实现；\n拦截 API 调用，并提供自己的实现；\n是一个优雅降级。")]),e._v(" "),n("h2",{attrs:{id:"polyfill"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#polyfill"}},[e._v("#")]),e._v(" Polyfill")]),e._v(" "),n("p",[e._v("polyfill 是一段代码(或者插件)，提供了那些开发者们希望浏览器原生提供支持的功能。程序库先检查浏览器是否支持某个API，如果不支持则加载对应的 polyfill。主要特征：")]),e._v(" "),n("p",[e._v("是一个浏览器 API 的 Shim;\n与浏览器有关;\n没有提供新的API，只是在 API 中实现缺少的功能;\n以只需要引入 polyfill ，它会静静地工作;\nshim 的概念要比 polyfill 更大一些，可以将 polyfill 理解为专门兼容浏览器 API 的 shim 。简单的说，如果浏览器X支持标准规定的功能，那么 polyfill 可以让浏览器 Y 的行为与浏览器 X 一样。")]),e._v(" "),n("h2",{attrs:{id:"javascript的-param注解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript的-param注解"}},[e._v("#")]),e._v(" JavaScript的@param注解")]),e._v(" "),n("p",[e._v("@param是对函数参数进行解释作用，大型项目所用\n/**\n//大括号写类型\n@param{number}a 第一个参数是数字类型\n@param{number}a 第二个参数是数字类型\n@returns 返回俩个参数的和\n*/\nfunction add(a,b){\nreturn a+b;\n}\n然后当你使用add函数时，会有提示")]),e._v(" "),n("h1",{attrs:{id:"css3之calc"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#css3之calc"}},[e._v("#")]),e._v(" CSS3之Calc")]),e._v(" "),n("p",[e._v("Published on Feb 20, 2021 in "),n("a",{attrs:{href:"https://106.54.190.214/index.php/category/web%E5%89%8D%E7%AB%AF/",target:"_blank",rel:"noopener noreferrer"}},[e._v("web前端"),n("OutboundLink")],1),e._v(" with "),n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/129/#comments",target:"_blank",rel:"noopener noreferrer"}},[e._v("0 comment"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"什么是calc"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是calc"}},[e._v("#")]),e._v(" 什么是Calc")]),e._v(" "),n("p",[e._v("calc是英文单词calculate的缩写，是css3的一个新增的功能，用来指定元素的长度。比如说，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。为何说是动态值呢?因为我们使用的表达式来得到的值。不过calc()最大的好处就是用在流体布局上，可以通过calc()计算得到元素的宽高。")]),e._v(" "),n("p",[e._v("如何使用\ncalc()使用通用的数学运算规则，但是也提供更智能的功能：")]),e._v(" "),n("p",[e._v("使用“+”、“-”、“"),n("em",[e._v('” 和 “/”四则运算；\n可以使用%、px、em、rem等单位；\n可以混合使用各种单位进行计算；\n表达式中有“+”和“-”时，其前后必须要有空格，如"widht: calc(12%+5em)"这种没有空格的写法是错误的；\n表达式中有“')]),e._v("”和“/”时，其前后可以没有空格，但建议留有空格。\n使用起来其实很简单，比如:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(".box {\n  width: calc(50% + 2em);\n  height: calc(100% - 2em);\n  background-color: #f00;\n}\n")])])]),n("h2",{attrs:{id:"隐藏scroll-view的滚动条"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#隐藏scroll-view的滚动条"}},[e._v("#")]),e._v(" // 隐藏scroll-view的滚动条")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("::-webkit-scrollbar {\n    display: none;\n    width: 0;\n    height: 0;\n    background-color: rgba($color: #bdbdbd, $alpha: 0);\n}\n")])])]),n("p",[e._v("本文由 "),n("a",{attrs:{href:"https://106.54.190.214/index.php/author/1/",target:"_blank",rel:"noopener noreferrer"}},[e._v("简素言也"),n("OutboundLink")],1),e._v(" 创作，采用 "),n("a",{attrs:{href:"https://creativecommons.org/licenses/by/4.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("知识共享署名4.0"),n("OutboundLink")],1),e._v(" 国际许可协议进行许可")]),e._v(" "),n("h1",{attrs:{id:"关于websocket和http协议"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关于websocket和http协议"}},[e._v("#")]),e._v(" 关于websocket和http协议")]),e._v(" "),n("p",[e._v("Published on Dec 25, 2020 in "),n("a",{attrs:{href:"https://106.54.190.214/index.php/category/web%E5%89%8D%E7%AB%AF/",target:"_blank",rel:"noopener noreferrer"}},[e._v("web前端"),n("OutboundLink")],1),e._v(" with "),n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/21/#comments",target:"_blank",rel:"noopener noreferrer"}},[e._v("0 comment"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"背景分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#背景分析"}},[e._v("#")]),e._v(" 背景分析:")]),e._v(" "),n("p",[e._v("完整的HTTP服务过程包括\n1.对www.xxx.com这个网址进行DNS域名解析,获取对应的请求\n2.根据这个IP,找到对应的服务器,发起TCP三次握手\n3.建立TCP连接后发起HTTP请求\n4.服务器响应HTTP请求,浏览器得到HTML代码\n5.浏览器解析HTML代码,并请求HTML代码的资源\n6.浏览器对页面进行渲染呈现给用户\n7.服务器关闭TCP连接")]),e._v(" "),n("p",[e._v("HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。")]),e._v(" "),n("p",[e._v("当用户在浏览器上进行操作时，可以请求服务器上的api；但是反过来却不可能：服务器端发生了一个事件，无法将这个事件的信息实时主动地通知客户端。只有在客户端查询服务器当前状态时，所发生事件的信息才会从服务器传递到客户端。")]),e._v(" "),n("h2",{attrs:{id:"那怎么去实时地知道服务器的状态呢"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#那怎么去实时地知道服务器的状态呢"}},[e._v("#")]),e._v(" 那怎么去实时地知道服务器的状态呢？")]),e._v(" "),n("p",[e._v("方法有两个：")]),e._v(" "),n("p",[e._v("（1）轮询：客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。")]),e._v(" "),n("p",[e._v("（2）长连接：客户端只请求一次，但是服务器会将连接保持，不会返回结果。当服务器有了新数据时，实时地发给客户端，而一直保持挂起状态。这种做法的也造成了大量的性能浪费。")]),e._v(" "),n("h2",{attrs:{id:"websocket-协议"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#websocket-协议"}},[e._v("#")]),e._v(" WebSocket 协议")]),e._v(" "),n("p",[e._v("最新的 HTML5协议，制定了 WebSocket 协议标准，允许客户端和服务器端以全双工的方式进行通信。")]),e._v(" "),n("p",[e._v("WebSocket 的原理非常简单：利用HTTP请求产生握手，HTTP头部含有 WebSocket 协议的请求，*握手之后，二者转用TCP协议进行交流（QQ的协议）。")]),e._v(" "),n("p",[e._v("WebSocket协议需要浏览器和服务器都支持才可以使用：")]),e._v(" "),n("p",[e._v("支持WebSocket协议的浏览器有：Chrome 4、火狐4、IE10、Safari5")]),e._v(" "),n("p",[e._v("支持WebSocket协议的服务器有：Node 0、Apach7.0.2、Nginx1.3")]),e._v(" "),n("h2",{attrs:{id:"http-长连接和-websocket-的长连接区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#http-长连接和-websocket-的长连接区别"}},[e._v("#")]),e._v(" http 长连接和 websocket 的长连接区别")]),e._v(" "),n("p",[e._v("HTTP1.1通过使用Connection:keep-alive进行长连接，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。")]),e._v(" "),n("p",[e._v("websocket是一个真正的全双工。长连接第一次tcp链路建立之后，后续数据可以双方都进行发送，不需要发送请求头。")]),e._v(" "),n("p",[e._v("keep-alive双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。")]),e._v(" "),n("h2",{attrs:{id:"socket-io-的引入"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#socket-io-的引入"}},[e._v("#")]),e._v(" Socket.IO 的引入")]),e._v(" "),n("p",[e._v("Node.js上需要写一些程序，来处理TCP请求。")]),e._v(" "),n("p",[e._v("Node.js从诞生之日起，就支持 WebSocket 协议。不过，从底层一步一步搭建一个Socket服务器很费劲（想象一下Node写一个静态文件服务都那么费劲）。所以，有大神帮我们写了一个库 Socket.IO。")]),e._v(" "),n("p",[e._v("Socket.IO 是业界良心，新手福音。它屏蔽了所有底层细节，让顶层调用非常简单。并且还为不支持 WebSocket 协议的浏览器，提供了长轮询的透明模拟机制。")]),e._v(" "),n("p",[e._v("Node的单线程、非阻塞I/O、事件驱动机制，使它非常适合Socket服务器。")]),e._v(" "),n("p",[n("a",{attrs:{href:"http://socket.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Socket.IO 的官网"),n("OutboundLink")],1)]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/21/#menu_index_1",target:"_blank",rel:"noopener noreferrer"}},[e._v("背景分析:"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/21/#menu_index_2",target:"_blank",rel:"noopener noreferrer"}},[e._v("那怎么去实时地知道服务器的状态呢？"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/21/#menu_index_3",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebSocket 协议"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/21/#menu_index_4",target:"_blank",rel:"noopener noreferrer"}},[e._v("http 长连接和 websocket 的长连接区别"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/21/#menu_index_5",target:"_blank",rel:"noopener noreferrer"}},[e._v("Socket.IO 的引入"),n("OutboundLink")],1)])]),e._v(" "),n("p",[e._v("本文由 "),n("a",{attrs:{href:"https://106.54.190.214/index.php/author/1/",target:"_blank",rel:"noopener noreferrer"}},[e._v("简素言也"),n("OutboundLink")],1),e._v(" 创作，采用 "),n("a",{attrs:{href:"https://creativecommons.org/licenses/by/4.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("知识共享署名4.0"),n("OutboundLink")],1),e._v(" 国际许可协议进行许可")]),e._v(" "),n("h1",{attrs:{id:"不要再问我跨域的问题啦"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#不要再问我跨域的问题啦"}},[e._v("#")]),e._v(" 不要再问我跨域的问题啦！")]),e._v(" "),n("p",[e._v("Published on Nov 17, 2020 in "),n("a",{attrs:{href:"https://106.54.190.214/index.php/category/web%E5%89%8D%E7%AB%AF/",target:"_blank",rel:"noopener noreferrer"}},[e._v("web前端"),n("OutboundLink")],1),e._v(" with "),n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/14/#comments",target:"_blank",rel:"noopener noreferrer"}},[e._v("0 comment"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("首先，我们需要明白什么是跨域，跨域源自于"),n("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy",target:"_blank",rel:"noopener noreferrer"}},[e._v("浏览器的同源策略"),n("OutboundLink")],1),e._v("\n协议、域名、端口，只要有一个不同，即为跨域。\n跨域请求可以正常发起，但是"),n("strong",[e._v("返回的结果会被浏览器拦截")]),e._v("\n他的作用是为了预防"),n("a",{attrs:{href:"https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("CSRF攻击"),n("OutboundLink")],1)]),e._v(" "),n("hr"),e._v(" "),n("h2",{attrs:{id:"解决方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[e._v("#")]),e._v(" "),n("strong",[e._v("解决方案")])]),e._v(" "),n("h3",{attrs:{id:"_1-jsonp"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-jsonp"}},[e._v("#")]),e._v(" 1. JSONP")]),e._v(" "),n("p",[e._v("在HTML标签里，一些标签比如script、img这样的获取资源的标签是没有跨域限制的（比如我们使用src引入外链、引入cdn）\n向服务端发送请求，返回的数据作为一个指定的回调函数的参数，在另一个script中指定这个回调函数，这样就可以获取到服务端数据了\n缺点：只支持GET请求，目前已经很少使用")]),e._v(" "),n("h3",{attrs:{id:"_2-cors"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-cors"}},[e._v("#")]),e._v(" 2. CORS")]),e._v(" "),n("p",[e._v('"跨域资源共享"（Cross-origin resource sharing）即，后端在服务器端的 HTTP 响应中添加响应头字段\nAccess-Control-Allow-Origin：* 前端Web发出跨域请求后，浏览器会自动向我们的HTTP\nheader添加一个额外的请求头字段：Origin，标记了请求的来源，所以前端不需要做任何事，即可跨域请求。\nCORS分成两类：简单请求和非简单请求')]),e._v(" "),n("p",[e._v("简单请求：请求为 GET、HEAD 或 POST，且请求头只有以下几种，此时请求无其他变化\nAccept、Accept-Language、Content-Language、Last-Event-ID、\nContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain")]),e._v(" "),n("p",[e._v("非简单请求：除简单请求之外皆为非简单请求 此时发送请求时，会先执行一次 OPTIONS\n查询请求（预检请求），以获知服务器是否允许该实际请求，然后再发送请求 不支持IE10以下，目前用的人不多")]),e._v(" "),n("h3",{attrs:{id:"_3-webpack反向代理-主流方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-webpack反向代理-主流方法"}},[e._v("#")]),e._v(" 3. Webpack反向代理（主流方法）")]),e._v(" "),n("p",[e._v("使用我们的node后端，去反向代理目标地址服务器，只在我们开发时有效（因为开发时我们才会启动node后端服务）\n具体方法为：在webpack.config.js中添加开发环境的配置")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("devServer: {\n  host: 'localhost', // 域名\n  port: 8080, // 端口号\n  // 服务器代理，--\x3e 解决开发环境的跨域问题\n  proxy: {\n    // 一旦 8080服务器接收到/api/xxx的请求，就会把请求转发到另外一个服务器3000\n    '/api': {\n      target: 'http://localhost:3000', // 表示目标资源的地址\n      //secure: false, // 设置支持https协议的代理\n      //changeOrigin: true, // target是域名的话，需要这个参数\n      // 发送请求时，请求路径重写：将/api/xxx --\x3e /xxx （去掉/api）\n      pathRewrite: {\n        '^/api': '' //如果本身的接口地址没有 '/api' 这种通用前缀，则需要rewrite\n      }\n    }\n  }\n}\n")])])]),n("h3",{attrs:{id:"_4-nginx反向代理-主流方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-nginx反向代理-主流方法"}},[e._v("#")]),e._v(" 4. Nginx反向代理 （主流方法）")]),e._v(" "),n("p",[e._v("Nginx是一种高性能的请求分发和反向代理web轻量服务器，类似于起到中转请求到真正数据存储服务器的中转站的作用\n原理同webpack反向代理，不过此时为后端配置")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("server{\n    # 监听9099端口\n    listen 9099;\n    # 域名是localhost\n    server_name localhost;\n    #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 \n    location ^~ /api {\n        proxy_pass http://localhost:9871;\n    }     }\n")])])]),n("p",[e._v("前端啥也不用干")]),e._v(" "),n("h3",{attrs:{id:"_5-websocket-高级小众方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-websocket-高级小众方法"}},[e._v("#")]),e._v(" 5. webSocket（高级小众方法）")]),e._v(" "),n("p",[e._v("是一种HTML5中新增的通信协议，比起http协议更加安全，为不受限的双向通信，不会产生跨域问题")]),e._v(" "),n("ul",[n("li",[e._v("解决方案\n"),n("ul",[n("li",[n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/14/#menu_index_2",target:"_blank",rel:"noopener noreferrer"}},[e._v("1. JSONP"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/14/#menu_index_3",target:"_blank",rel:"noopener noreferrer"}},[e._v("2. CORS"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/14/#menu_index_4",target:"_blank",rel:"noopener noreferrer"}},[e._v("3. Webpack反向代理（主流方法）"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/14/#menu_index_5",target:"_blank",rel:"noopener noreferrer"}},[e._v("4. Nginx反向代理 （主流方法）"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/14/#menu_index_6",target:"_blank",rel:"noopener noreferrer"}},[e._v("5. webSocket（高级小众方法）"),n("OutboundLink")],1)])])])]),e._v(" "),n("h1",{attrs:{id:"关于原型链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关于原型链"}},[e._v("#")]),e._v(" 关于原型链")]),e._v(" "),n("p",[e._v("Published on Nov 12, 2020 in "),n("a",{attrs:{href:"https://106.54.190.214/index.php/category/%E5%90%8E%E7%AB%AF/",target:"_blank",rel:"noopener noreferrer"}},[e._v("后端开发"),n("OutboundLink")],1),e._v(" with "),n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/90/#comments",target:"_blank",rel:"noopener noreferrer"}},[e._v("0 comment"),n("OutboundLink")],1)]),e._v(" "),n("h3",{attrs:{id:"对于prototype的认识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对于prototype的认识"}},[e._v("#")]),e._v(" 对于prototype的认识")]),e._v(" "),n("p",[e._v("每一个"),n("strong",[e._v("函数")]),e._v("都有一个属性叫做prototype，它的属性值是一个对象，在这个对象中默认有一个constructor属性，指向这个函数的本身。")]),e._v(" "),n("h3",{attrs:{id:"对于-proto-的的认识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对于-proto-的的认识"}},[e._v("#")]),e._v(" 对于__proto__的的认识")]),e._v(" "),n("p",[e._v("__proto__是隐式原型，每一个"),n("strong",[e._v("对象")]),e._v("都有一个这样的隐式原型属性，"),n("strong",[e._v("它引用了创建这个对象的函数的prototype。")])]),e._v(" "),n("h3",{attrs:{id:"prototype和-proto-的关系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prototype和-proto-的关系"}},[e._v("#")]),e._v(" prototype和__proto__的关系")]),e._v(" "),n("p",[e._v("所有的对象"),n("strong",[e._v("都是")]),e._v("由Object继承而来，对象"),n("strong",[e._v("都是")]),e._v("由函数来创建的。\n需要注意的是，函数也是对象，自然它也有__proto__。")]),e._v(" "),n("p",[n("strong",[e._v("构造函数的显式原型的值为其对应实例对象的隐式原型的值。")]),e._v("\n即 Function.prototype === fuction."),n("strong",[e._v("proto")])]),e._v(" "),n("p",[n("strong",[e._v("所以的函数都是构造函数Function的实例，包括Function自身（new 自己）")]),e._v("\n所以： Function."),n("strong",[e._v("proto")]),e._v(" === Function.prototype")]),e._v(" "),n("p",[e._v("原型链：沿着隐式原型__proto__查找（隐式原型链）对象的属性")]),e._v(" "),n("p",[e._v("原型继承： 构造函数的实例对象，自动拥有构造函数原型对象的属性和方法")]),e._v(" "),n("p",[e._v("object对象的原型尽头是原型链尽头，即为 null\n"),n("img",{attrs:{src:"E:%5Csyy-notes%5Cdocs.vuepress%5Calias%5C472868472.jpg",alt:"10.12.jpg"}})]),e._v(" "),n("h1",{attrs:{id:"详谈后台管理系统的权限控制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#详谈后台管理系统的权限控制"}},[e._v("#")]),e._v(" 详谈后台管理系统的权限控制")]),e._v(" "),n("p",[e._v("Published on Oct 27, 2020 in "),n("a",{attrs:{href:"https://106.54.190.214/index.php/category/%E5%90%8E%E7%AB%AF/",target:"_blank",rel:"noopener noreferrer"}},[e._v("后端开发"),n("OutboundLink")],1),e._v(" with "),n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/80/#comments",target:"_blank",rel:"noopener noreferrer"}},[e._v("0 comment"),n("OutboundLink")],1)]),e._v(" "),n("h3",{attrs:{id:"序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#序"}},[e._v("#")]),e._v(" 序")]),e._v(" "),n("p",[e._v("自己在做后台系统的时候涉及到权限管理这一块,于是乎总结了关于这方面的处理方法。权限管理一般是后端配合前端完成的,前端所做的就是控制视图层的展示和控制前端请求,简单理解就是降低非法操作和提高用户体验以及减轻服务器压力")]),e._v(" "),n("p",[e._v("思路如下：\n1.导航栏的控制")]),e._v(" "),n("p",[e._v("在登录请求中， 会得到权限数据， 当然， 这个需要后端返回数据的支持． 前端根据权限数据， 展示对应的菜单． 点击菜单， 才能查看相关的界面")]),e._v(" "),n("p",[e._v("2.UI界面的控制")]),e._v(" "),n("p",[e._v("如果用户没有登录， 手动在地址栏敲入管理界面的地址， 则需要跳转到登录界面 如果用户已经登录， 如果手动敲入非权限内的地址， 则需要跳转404 界面或者危险操作提示 如果用户已经登录， 如果手动敲入登录的地址， 则需要提示并不做路由反应")]),e._v(" "),n("p",[e._v("3.按钮的控制")]),e._v(" "),n("p",[e._v("在某个菜单的界面中， 根据权限数据， 展示出可进行操作的按钮，比如删除， 修改， 增加")]),e._v(" "),n("p",[e._v("4.请求和响应的控制")]),e._v(" "),n("p",[e._v("如果用户通过非常规操作， 比如通过浏览器调试工具将某些禁用的按钮变成启用状态， 此时发的请求， 也可以被前端所拦截")]),e._v(" "),n("h2",{attrs:{id:"实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[e._v("#")]),e._v(" 实现")]),e._v(" "),n("h3",{attrs:{id:"菜单栏控制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#菜单栏控制"}},[e._v("#")]),e._v(" 菜单栏控制")]),e._v(" "),n("p",[e._v("用户登录之后,拿到token,然后请求数据,根据这个数据对菜单栏进行渲染,类似于这种,但是最好将token和菜单信息不放在一个接口中,")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("{\n id: 1,\n username: 'admin',\n password: 'admin',\n token: 'abcd12efghqwe23klmnopqrstuvwx31234qr34yz',\n rights: [{\n   id: 1,\n   authName: '一级菜单',\n   icon: 'icon-menu',\n   children: [{\n     id: 11,\n     authName: '一级项目1',\n     path: 'goods',\n     rights: ['view', 'edit', 'add', 'delete']\n   }, {\n     id: 11,\n     authName: '一级项目2',\n     path: 'fetch',\n     rights: ['view']\n   }]\n }]\n}\n")])])]),n("p",[e._v("拿到数据后把数据存入vuex中,同时存入本地的sessionStorage中,并保持数据同步,然后主页根据vuex中的数据进行菜单列表的渲染\n在退出登陆的时候")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("logOut(){\n    sessionStorage.clear()  //删除sessionStorage数据\n    this.$router.push('/login')\n    window.location.reload()  //删除vue数据,让当前页面刷新\n}\n")])])]),n("h3",{attrs:{id:"界面的控制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#界面的控制"}},[e._v("#")]),e._v(" 界面的控制")]),e._v(" "),n("p",[e._v("解决在未登录情况下在网址栏输入地址跳转进入管理平台")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("router.beforeEach((to, from, next) => {\nif (to.path === '/login') {\n next()\n} else {\n const token = sessionStorage.getItem('token')\n if (!token) {\n   next('/login')\n } else {\n   next()\n }\n}\n}\n")])])]),n("p",[e._v("解决登陆后用户角色权限不够但仍能够使用网址进入所有路由,使用动态路由")]),e._v(" "),n("p",[e._v("首先,将需要权限控制的路由单独定义")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import Vue from 'vue'\nimport VueRouter from 'vue-router'\nimport store from '@/store'\n//默认页面\nimport Home from '@v/Home.vue'\nimport Login from '@v//Login.vue'\nimport NotFound from '@v//NotFound.vue'\nimport GoodsList from '@c/goods/GoodsList.vue'\nimport mapList from '@c/goods/mapList.vue'\nimport fetchList from '@c/goods/fetchList.vue'\n//需要权限规则的单独定义\n\nconst GoodsRule = { path: '/Goods', component: GoodsList }\nconst mapRule = { path: '/map', component: mapList }\nconst fetchRule = { path: '/fetch', component: fetchList }\n\n//后端拿到的路径字符串与权限路由进行映射\nconst ruleMapping = {\n  'goods': GoodsRule,\n  'map': mapRule,\n  'fetch': fetchRule\n}\n\n//不会在路由中定义需要的权限路由,而是动态添加\nconst routes = [{\n  path: '/',\n  name: 'Home',\n  component: Home,\n  redirect: '/menu/one',\n  children: [{\n    path: '/menu/one',\n    component: () =>import('@/views/Page1.vue')\n  }]\n  },\n  {\n    path: '/login',\n    name: 'Login',\n    component: Login\n  },\n  {\n    path: '*',\n    name: 'NotFound',\n    component: NotFound\n  }]\nexport function initDynamicRouters() {\n  //根据二级权限动态添加路由\n  // console.log(router)\n  //当前路由信息\n  const currentRoutes = router.options.routes\n  // 从vuEx拿到数据遍历添加\n  const rightList = store.state.rightList\n  rightList.forEach(item => {\n    item.children.forEach(v => {\n      //二级权限(根据字段给它分配对应的路由)\n      const temp = ruleMapping[item.path]\n      //给路由meta中添加当前角色可做的权限,在按钮控制中需要\n    temp.meta=item.rights\n      //添加动态路由\n      currentRoutes[2].children.push(temp)\n    })\n  })\n  //将更改之后的结果重新设置给路由对象\n  router.addRoutes(currentRoutes)\n}\n")])])]),n("p",[e._v("如果重新刷新的话动态路由就会消失，动态路由是在登录成功之后才会调用的，刷新的时候并没有调用，所以动态路由没有添加上,可以在app.vue中的created中调用添加动态路由的方法initDynamicRouters")]),e._v(" "),n("h3",{attrs:{id:"按钮的控制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#按钮的控制"}},[e._v("#")]),e._v(" 按钮的控制")]),e._v(" "),n("p",[e._v("虽然用户可以看到某些界面了， 但是这个界面的一些按钮该用户可能是没有权限的。 因此， 我们需要对组件中的一些按钮进行控制， 用户不具备权限的按钮就隐藏或者禁用， 而在这块的实现中， 可以把该逻辑放到自定义指令中,参考 官方描述")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<el-button\n    type=\"success\"\n    @click=\"addDiaLogVis=true\"\n    v-permission=\"{action:'add' ,effect:'disable'}\">\n    添加用户\n</el-button>\nimport Vue from \"vue\"\nimport router from '@/router.js'\nVue.directive('permission', {\n  inserted(el, binding) {\n    //拿到例子中action的值,值为`add`,表示进行添加操作\n    const action = binding.value.action\n    //拿到例子中effect的值,值为`disable`,表示不可操作\n    const effect = binding.value.effect\n    //可以获取当前路由中用户角色是否具备action的权限\n    //console.log(router.currentRoute.meta)\n    //判断当前路由中用户角色是否具备action的权限\n    if (router.currentRoute.meta.indexOf(action) == -1) {\n      if (effect === 'disabled') {\n    //禁用\n        el.disabled = true\n        el.classList.add('is-disabled')\n      } else {\n    //移除\n        el.parentNode.removeChild(el)\n      }\n    }\n  }\n})\n")])])]),n("h3",{attrs:{id:"请求的控制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#请求的控制"}},[e._v("#")]),e._v(" 请求的控制")]),e._v(" "),n("p",[e._v("前端代码--\x3e在axios发送前做一些处理 请求拦截器，响应拦截器")]),e._v(" "),n("h1",{attrs:{id:"css3-html5-新增特性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#css3-html5-新增特性"}},[e._v("#")]),e._v(" CSS3/HTML5 新增特性")]),e._v(" "),n("p",[e._v("Published on Oct 7, 2020 in "),n("a",{attrs:{href:"https://106.54.190.214/index.php/category/web%E5%89%8D%E7%AB%AF/",target:"_blank",rel:"noopener noreferrer"}},[e._v("web前端"),n("OutboundLink")],1),e._v(" with "),n("a",{attrs:{href:"https://106.54.190.214/index.php/archives/6/#comments",target:"_blank",rel:"noopener noreferrer"}},[e._v("0 comment"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://106.54.190.214/index.php/tag/web%E5%89%8D%E7%AB%AF/",target:"_blank",rel:"noopener noreferrer"}},[e._v("web前端"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("子元素")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("li: nth-child(1) {}\n")])])]),n("p",[e._v("水平居中的多种方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("margin: 0 auto;  \n\ntext-align: center;\n\nposition: absolute;\nleft: 50%;\ntop: 50%;\ntransform: translate(-50%, -50%)\n")])])]),n("p",[e._v("垂直居中\n"),n("code",[e._v("line-hight: height")]),e._v(" 行高等于hight即为垂直居中")]),e._v(" "),n("p",[e._v("overflow:hidden的多种用法\n1.父级元素内部子元素，添加margin-top样式，那么父级元素也会跟着下来，造成 外边距塌陷 ,给父级元素添加overflow:hidden，就可以解决")]),e._v(" "),n("p",[e._v("2.父级元素内部的子元素全部都设置浮动float之后，子元素会脱离标准流，不占位，父级元素检测不到子元素的高度，父级元素高度为0。\n给父级加个overflow:hidden属性,清除浮动；在IE中兼容为 zoom:1")]),e._v(" "),n("p",[e._v("3.给一个元素中设置overflow:hidden，那么该元素的内容若超出了给定的宽度和高度属性，那么超出的部分将会被隐藏，不占位。\n--\x3e")]),e._v(" "),n("p",[e._v("overflow:auto的用法\n")]),e._v(" "),n("p",[e._v("去除空白空隙")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("vertical-align: top ;\n")])])]),n("p",[e._v("CSS3(层叠样式表)新语句\n"),n("code",[e._v("border-radius：15px")]),e._v(" 圆角\n"),n("code",[e._v("box-shadow：10px 10px 5px #888888;")]),e._v(" 阴影\n"),n("code",[e._v("border-image:url(border.png) 30 30 stretch或round;")]),e._v(" 图片边框")]),e._v(" "),n("p",[e._v("渐变 "),n("code",[e._v("background-image: linear-gradient(direction, color-stop1, color-stop2, ...);")]),e._v("\n文本溢出 "),n("code",[e._v("text-overflow: clip/ellipsis;")]),e._v("\n换行 "),n("code",[e._v("p{word-wrap:break-word; }")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("word-break: keep-all/break-all;\n")])])]),n("p",[e._v("引入字体")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("@font-face{font-family: myFirstFont;src:url();}\ndiv{font-family:myFirstFont;}\n")])])]),n("p",[e._v("2D转换和3D转换")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("translate(x,y)；rotate(angle角度，如30deg)；scale(x,y)；skew()；matrix()\n")])])]),n("p",[e._v("过渡")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("transition: 属性1 过渡时间1，属性2 时间2，...;\n")])])]),n("p",[e._v("动画\n1.先创建动画,指定css样式和新的样式\n例如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" @keyframes 动画名字{\n  from {background:red;}\n  to {background:yellow;}\n}\n")])])]),n("p",[e._v("2.然后将动画绑定到一个选择器，规定动画时长\n例如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" div{\n  animation: 动画名字 5s;\n}\n")])])]),n("p",[e._v("创建多列 例：分割三列 colum-count:3；")]),e._v(" "),n("p",[n("code",[e._v("resize:both")]),e._v(" 用户可调整某个元素大小\n"),n("code",[e._v("box-sizing: border-box;")]),e._v("-----C3盒子模型：盒子的宽度=width（里面包换了 border和padding，不会撑大盒子了）\n"),n("code",[e._v("box-sizing: content-box;")]),e._v("-----传统模式：盒子的宽度=CSS中设置的width+border+padding；")]),e._v(" "),n("p",[e._v("图片 image\n可以通过改变border，padding来修改图片")]),e._v(" "),n("p",[e._v("css3分页样式")]),e._v(" "),n("p",[e._v("flex box弹性盒子\n多媒体查询 "),n("code",[e._v("@media 媒体类型 not|only|and （媒体特性）{}")]),e._v("\n例如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" @media screen and (min-width:320px){\n  div{\n    background-color: red;\n  }\n}\n")])])]),n("p",[e._v("透明 opacity属性为0.0-1.0之间")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("{opacity:0.4;\n  filter:alpha(opacity=40); /* IE8 及其更早版本 */}\n")])])]),n("p",[e._v("HTML5 中的一些有趣的新特性：")]),e._v(" "),n("p",[e._v("用于绘画的 canvas 元素（图形标签）\n内联SVG （可伸缩矢量图 ）\n例如：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<svg xmlns="http://www.w3.org/2000/svg" version="1.1">\n  <circle圆形  cx="100" cy="50"圆心100.50，半径40 r="40" stroke="black"\n  stroke-width="2"黑框 fill="red"红底 /> </svg>\n')])])]),n("p",[e._v("用于媒介回放的 video 和 audio 元素\n对本地离线存储的更好的支持\n新的特殊内容元素，比如 article、footer、header、nav、section\n新的表单控件，比如 calendar、date、time、email、url、search")])])}),[],!1,null,null,null);t.default=a.exports}}]);